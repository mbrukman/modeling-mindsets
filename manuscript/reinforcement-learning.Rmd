# Reinforcement Learning {#reinforcement-learning}

* Reinforcement learning models an agent that interacts with its environment.
* It's used in robotics, games, complex systems, and simulations.
* Together with [supervised](#supervised) and [unsupervised](#unsupervised-ml) learning, reinforcement learning is a [machine learning](#machine-learning) mindset.


<!-- motivation: joke about how static other mindsets are -->
*Two machine learners attend a dinner with a huge buffet.
Dumplings are in high demand, but unavailable most of the time.
The supervised learner tries to predict when the waiters refill the dumplings.
The reinforcement learner leaves and returns with a plate full of dumplings.
"How did you get these dumplings?" asks the supervised learner.
"First I tried my luck at the buffet, but of course the dumplings were gone," explains the reinforcement learner.
"Then I thought about my options and decided to talk to a waiter.
That decision was rewarded with dumplings!"
The supervised learner was stunned, as interacting with the environment never seemed to be an option.*


<!-- motivation: super-human gamers -->
Chess, Go, StarCraft II, Minecraft, Atari games, ...
Many people enjoy playing these games.
But they are not the only ones.
Computers also play these games.
And they play them at a super-human level.

All these games require long-term planning and difficult decisions.
In Go, there are $10^{127}$ possible board positions, more than there are atoms in the universe (about $10^{78}$ to $10^{82}$).
StarCraft II is a complex real-time strategy game that requires planning, resource management and military tactics.
Playing these games at superhuman levels was made possible by machine learning.
Super-human game play was made possible by machine learning.
But not through supervised or unsupervised learning.
It is the third modeling mindset that has outplayed us humans.
A modeling mindset that gives the computer a "brain" and turns into an agent acting in an environment.

Welcome to **reinforcement learning**!

## Reinforcement Learning

<!-- reinforcement learning theory in a nutshell -->
At the center of a reinforcement learning model is the agent.
This agent doesn't sell houses, it doesn't fight Neo, and it doesn't investigate crimes.
No. 
Reinforcement learning agents play Go[@silver2016mastering], plan routes, control cooling units[@li2019transforming], move robotic arms [@gu2017deep], steer self-driving cars[@kiran2021deep] or guide image segmentation[@wang2018outline].
An agent in reinforcement learning is an entity that interacts with an environment with the goal of maximizing rewards.
This environment can be a video game, a city map, a cooling system, an assembly line in a factory, ...
The agent observes the environment, but also acts in it, thereby changing it.
But how does the agent choose it's actions?
Similar to humans, the agent is "motivated" by rewards:
Defeating the other players in StarCraft, setting the right temperature in the building, collecting coins in Super Mario.
The "brain" of the agent is the policy.
The policy decides what the agent should do next, depending on the situation it is in.
<!-- A policy can be deterministic (Do A) or stochastic (Do A with 90% probability and B with 10%). -->

```{r rl, fig.cap = "Reinforcement Learning.", fig.height = 2, fig.width = 6}
r1 = rectFun(c(0, 0))
r2 = rectFun(c(0, 5)) 

p = ggplot(mapping = aes(x = x, y = y)) +
  geom_path(data = r1) +
  annotate("text", label = "Environment", x = 0, y = 5) + 
  geom_path(data = r2) +
  annotate("text", label = "Agent", x = 0, y = 0) + 
  annotate("curve", x = 0.65, y = 0, xend = 0.65, yend = 5, size = 1, curvature = 0.5, arrow = arrow(ends = "first"))  +
  annotate("label", x = 0.9, y = 2.5, label = "Observation,\nReward") +
  annotate("curve", x = -0.65, y = 5, xend = -0.65, yend = 0, size = 1, curvature = 0.5, arrow = arrow(ends = "first")) +
  annotate("label", x = -0.9, y = 2.5, label = "Action") +
  scale_x_continuous(limits = c(-2.1, 2.1)) +
  theme_void()

add_cc(p, size = 8)
```

## A Dynamic Mindset

<!--  RL is dynamic -->
Reinforcement learning is dynamic.
When using reinforcement learning to solve a task, the task is viewed as an interaction between a computer (program) and another system or environment.
In comparison, the other mindsets are stationary.
They work with static snapshots of the world.
Interaction between computer and environment isn't part of all the other modeling mindsets such as supervised learning or Bayesianism. 
In most modeling mindsets, data are usually collected first and then the model is built.
In reinforcement learning, the data are generated by the agent's interaction with the environment.[^pretrained]
The agent chooses which states of the environment to explore and in turn which data to generate.
The computer runs its own experiments and learns from them.
The agent goes through a cycle:

- Observation: Look at the world.
- Action: Interact with the world.
- Reward: Get feedback on previous action(s).

<!-- product pricing example -->
Think about pricing a product.
A high price means more revenue per sale, but fewer customers.
A low price means more customers, but less revenue per sale.
The seller wants to find the optimal price that balances demand and revenue per sale.
What about using supervised learning?
Simply train a model to predict the number of sales based on price and other factors (day of the week, promotions, ...).
To train such a model, you need historical data with different prices.
But even if you had such data, it would probably be suboptimal.
It's likely that the data were not generated by an experimental design.
Perhaps the optimal price is higher than any historical price.
But supervised learning can only learn from observed data; it can't explore new options.

<!-- RL is holistic part II -->
Reinforcement learning can deal with this dynamic pricing situation.
A change in price changes the "environment", in our case the sales, inventory, etc.
Reinforcement learning is a way to conduct experiments with the price.
It can handle the trade-off between exploring new prices and exploiting already learned pricing strategies. 
This makes reinforcement learning a much more holistic approach that connects interactions.

<!-- still ml mindset -->
Reinforcement learning is a typical machine learning mindset.
Maybe even more so than supervised and unsupervised learning.
One motivation of machine learning is to make the computer act intelligently.
We humans can better relate to a machine if it is intelligent in the human sense (and not just a calculator).
By "embodying" the computer as an agent in an environment, reinforcement learning conveys this concept of intelligence. 
We are amazed when a machine can play games, perhaps even in a human-like manner. 

<!-- ml mindset on technical level as well -->
Reinforcement learning also meets the other criteria for a machine learning mindset.
We don't care how exactly the agent policy is implemented -- as long as it works.
Or, as Ovid said, "Exitus acta probat", the result justifies the deed.
How good the result is can be measured very directly by the rewards.
Just average the rewards over several episodes (an episode is one game, or a simulation round) and compare these across models.
A reward is an external signal and doesn't rely on model assumptions (as many evaluation methods in statistics do).
But what is a reward anyway and is it different from labels in supervised learning?

<!-- the core of RL -->
<!--
To decide whether a problem can be solved with reinforcement learning, one has to:

- Define the problem as an agent interacting with an environment
- Define actions that can be taken.
- Define how the environment is encoded: Input pixels? game state?
- Define a reward function. This is very delicate.
- Choose a reinforcement learning algorithm, depending on cardinality of input and action space, difficulty of the problem and so on.
-->

  
###  Reward and Value

<!-- agents are all too human -->
Relaxing is easy; exercising is hard.
But why?
There are immediate negative rewards associated with exercise: 
It's tiring, you have to shower afterwards, you have to fit it into your daily routine,  ...
There are also huge positive rewards, such as getting fit and strong, reducing the risk of heart attacks, and prolonging life.
These positive rewards occur with a delay of weeks, years or even decades.
Reinforcement learning agents also deal with delayed rewards.
In addition, rewards can be sparse.
For example, in Tic-tac-toe, there is only a single reward at the end of the game (win or lose).
Most actions are without immediate reward and therefore without feedback.
In Tic-tac-toe, if the agent loses after 4 moves, how is it supposed to know which moves where the bad ones?

<!-- Value function -->
One solution is to assign a value to each state -- even to those that have no reward.
If there are only a few possible states, as in Tic-tac-toe, we can create a table with all possible states and their values.
If states are continuous or the space is too large, we can express the value as a function.
The value function accepts a state as input, or possibly a combination of state and action.
And the output is the value.

<!-- what is a value -->
But what is a value?
Simply put, the value tells how good it is for the agent to be in that state.
Value is the expected reward for a state or state-action pair.
You can think of value as the reward being spread back in time, like jam on a loaf of bread.
If you exercise today, it's because you know the value of exercising.
You imagine the future reward for your actions today and value the current state accordingly.
Or maybe you don't think about the value at all because working out has become a habit for you.
It has become your policy.

<!-- how to learn value functions? -->
Rewards are provided by the environment, but the values are not.
The values or the value function can only be estimated.
There are several ways to learn the value function.
One way is to turn it into a supervised learning task!
<!-- predict the cumulated rewards given a certain state. -->
The Go algorithm Alpha Zero, for example, did exactly that.
Through self-play, Alpha Zero collected a dataset of state-reward pairs.
Researchers trained a neural network on this dataset to predict win (+1) or loss (-1) as a function of the game state.
Another approach to learning the value function is Monte Carlo estimation:
We start from random initial states, follow the current policy of the agent, and accumulate the rewards.
Then we average the rewards for each state.
Monte Carlo estimation works only for environments with few states.

```{r rl-trajectory, fig.cap = "Trajectory of a reinforcement learning agent through the state space, with a reward at the end.", fig.width = 14, fig.height = 6}

# State size
ssize = 12
# Actor size
asize = ssize
# label.size
lsize = 1.2
arr = arrow(length = unit("0.2", "inch"))
# arrow size
arrsize = 1.6

p = ggplot() +
  # Time step 1 
  annotate("segment", x = 0.9, xend = 0.9, y = 0.8, yend = -0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 1.1, xend = 1.1, y = -0.8, yend = 0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 1.6, xend = 2.4, y = 1, yend = 1, arrow = arr, size = arrsize) + 
  annotate("label", x = 1, y = 1, label = "State 0", size = ssize, label.size = lsize) +
  annotate("label", x = 1, y = -1, label = "Actor", size = asize, label.size = lsize) +
  # Time step 2 
  annotate("segment", x = 2.9, xend = 2.9, y = 0.8, yend = -0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 3.1, xend = 3.1, y = -0.8, yend = 0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 3.6, xend = 4.4, y = 1, yend = 1, arrow = arr, size = arrsize) + 
  annotate("label", x = 3, y = 1, label = "State 1", size = ssize, label.size = lsize) +
  annotate("label", x = 3, y = -1, label = "Actor", size = asize, label.size = lsize) +
  # Time step 3
  annotate("segment", x = 4.9, xend = 4.9, y = 0.8, yend = -0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 5.1, xend = 5.1, y = -0.8, yend = 0.8, arrow = arr, size = arrsize) +
  annotate("segment", x = 5.6, xend = 6.4, y = 1, yend = 1, arrow = arr, size = arrsize) + 
  annotate("label", x = 5, y = 1, label = "State 2", size = ssize, label.size = lsize) +
  annotate("label", x = 5, y = -1, label = "Actor", size = asize, label.size = lsize) +
  # Time step 2
  annotate("segment", x = 7, xend = 7, y = 1, yend = 1.4, size = arrsize) +
  annotate("label", x = 7, y = 1, label = "State 3", size = ssize, label.size = lsize) +
  annotate("label", x = 7, y = 1.5, label = "Reward", size = ssize, label.size = lsize) +
  annotate("label", x = 7, y = -1, label = "Actor", size = asize, label.size = lsize) +
  annotate("segment", x = 7, xend = 7, y = 0.8, yend = -0.8, arrow = arr, size = arrsize) +

  coord_fixed() +
  theme_void() +
  scale_y_continuous(limits = c(-1.1, 1.7)) +
  scale_x_continuous(limits = c(0, 8)) 

add_cc(p, 14)

```

Defining the reward can be surprisingly tricky.
An agents can behave like an evil genie who takes wishes (aka rewards) quite literally.
A good example is  CoastRunners, a boat racing game.
The ultimate goal is to finish the race first, but the score (aka reward) was increased by collecting objects on the race course.
The agent learned not to finish the race.
Instead, it learned to go around in circles and collect the same reappearing objects over and over again. 
The greedy agent scored on average [20% more points than humans](https://openai.com/blog/faulty-reward-functions/).

## What to Learn

<!-- what should the agent learn? -->
For me, this was the most confusing part to getting started with reinforcement learning:
What function(s) are we actually learning in reinforcement learning?
In supervised learning, it's very clear.
We learn the function that maps the features to the label.
But it's not clear what the reinforcement agent is supposed to learn.
And in fact, there are many different possible approaches:  

- Learn a complete model of the environment. The agent can query such a model to simulate what the best action would be for each time step.
- Learn the state value function. If an agent has access to a value function, it can choose actions that maximize the value.
- Learn the action-value function, which takes as input not just the state, but state and action. 
- Learn the policy directly.

These approaches are not mutually exclusive, but can be combined.
Oh, and also, we have many different ways **how** we learn these things.
And that depends a lot on the dimensionality of the environment and the actions space.
For example, Tic-tac-toe and Go are pretty similar games.
I imagine all the Go players reading this book will object, but here me out.
Two players face in a fierce, turn-based strategy game!
The battlefield is a rectangular board with a grid.
Each player places markers on the grid.
The winner is determined by the constellations of the markers.

Despite some similarities, the games differ significantly in their difficulty for both humans and reinforcement learning.
Tic-tac-toe is often used as an example in reinforcement learning entry classes and is a "solved" problem.
In contrast, Go  has long been dominated by humans.
The first super-human Go agent [beat](https://en.wikipedia.org/wiki/AlphaGo_versus_Lee_Sedol) the Go champion Lee Sedol in 2016, which was a big media spectacle and required many computational resources.
The relevant differences between Tic-tac-toe and Go are the size of action space and state space.

<!-- Tic-tac-toeis easy -->
In Tic-tac-toe, there are at most 9 possible actions and on the order of $10^3$ possible action-state pairs.
The agent can learn to play Tic-tac-toe by using Q-learning, a model-free reinforcement learning approach to learn the value of an action in a given state.
Q-learning basically enumerates the state-action pairs and iteratively updates the values as more and more games are played.
<!-- Go is different -->
In Go, there are $\sim 10^{170}$ possible states.
We can't enumerate this set of states.
To work with these high-dimensional state and action spaces, we need to use neural networks (more on this later).

If you find or found it difficult to get started with reinforcement learning, it's not you.
It's difficult because there are so many possibilities for how to train a reinforcement learning agent.

## Is Reinforcement Learning Supervised?

<!-- RL versus supervised -->
At first glance, rewards seem similar to ground truth in supervised learning.
Especially if we have a value function, we could learn the policy with supervised learning, right?
Not really.
Supervised learning alone is unsuitable for sequential decision making that requires balancing exploration and exploitation.
Imagine modeling a game like Go with a supervised learning mindset.
We would choose the next move as the target to predict and use the game state as the input.
We could use recordings of human game as training data.
At best, this supervised approach would mimic average human players.
But it could never explore novel strategies.
There would be no creative freedom and no path to super-human gameplay.
Compared to reinforcement learning, supervised learning seems short-sighted and narrow-minded.
Supervised learning only considers parts of the problem without connecting actions.
Reinforcement learning is a much more holistic approach that sequentially connects interactions.

<!--
Reinforcement learning has links to psychology and neuroscience.
It draws from machine learning, but also operations research, control theory, statistics and optimization.
-->



<!-- RL versus unsupervised learning 
Reinforcement learning is also not unsupervised learning.
The reward is a sparse but strong signal for what to learn.
Unsupervised learning does not have such a unique signal.
Not every reinforcement learning problem has such a clear reward, sometimes they have to be designed.
That brings the two mindsets a bit closer.
But still, they are very different for other reasons:
Unsupervised learning lacks all these ideas of interacting with an environment, delayed rewards and so on. 
In a way, reinforcement learning is more similar to supervised learning.
That's because the rewards resembles a ground truth, even if it works differently from supervised learning.
Putting things together, is there maybe something like unsupervised reinforcement learning?
Indeed, there is.
And the idea is that the reward is not extrinsic, but rather intrinsic.
Similar to clustering: Here we decide on a criterion for what an interesting cluster would look like, without knowing whether the resulting grouping is "true".

-->

<!-- RL versus statistical modeling
Reinforcement learning takes a good scoop from statistical modeling.
How we talk about many concepts in reinforcement learning is in statistical terms.
We talk about probablities for actions, Markov decision processes and so on.
The mindset, however, is very different.
And it boils down to reinforcement learning being a machine learning mindset.
How the policy is learned and so on is not as important as getting the job done.
The statistical modeling mindset would be all about modeling variables explictly, relating them to each other, ...
Again, statistics here is the language with which we describe reinforcement learning, but the mindsets are different.
There is an interesting link to [causal inference](#causal-inference):
Due to reinforcement learning time-dependency, and the reward and so on, the actions have to be causal.
Let's say that in StarCraft the winning player often has the most units.
But if an agent would build a lot of worthless units, it would not win the game.
While the mere number of units is correlated with winning, it's not strictly causal.
Having lots of resources and building the right units is causal for winning.
An agent would not learn a policy that proposes non-causal actions, simply because they will not lead to a reward.
However, the agent can learn to rely on non-causal observations, which makes it vulnerable.
-->

## Deep Reinforcement Learning

<!-- mixing RL and DL is a good idea -->
The connection between deep learning and reinforcement learning is a bit more special, so let's go deeper here (pun intended).
In short: it's a fantastic fusion of mindsets.
Reinforcement learning alone struggles with high-dimensional inputs and large state spaces.
Go, for example, was too complex for reinforcement learning to solve.
Other environments where the states are images or videos also difficult to model.
Unless you throw deep learning into the mix.

<!-- use DL for complex RL functions -->
Deep reinforcement learning has gotten many people excited about AI in general.
Reinforcement learning is made "deep" by replacing some functions with deep neural networks.
For example, the value function or the policy function.
Using deep neural networks allows for more complex inputs such as images.
A successful example of deep reinforcement learning is Alpha Zero.
Alpha Zero can play Go on a super-human level.
Alpha Zero relies on two deep neural networks: a value network and a policy network.
A dataset is created from the algorithm playing against itself.
This dataset stores all the states of the board and the final outcome (win or loss) for each game.
The value network is trained on this self-play data to predict the outcome of the game (between -1 and +1) from the Go board.
The policy network outputs action probabilities based on the Go board (the state).
But the agent doesn't automatically follow the most likely action.
Instead, the policy network works in tandem with a Monte Carlo tree search algorithm.
The Monte Carlo tree search connects the policy with the value of the board and simulates possible next moves.
Training of the policy network is also interwoven with the Monte Carlo tree search.

<!-- RL in general -->
Deep reinforcement learning is an exciting combination of the two mindsets.
It has lead to great success in many games and is being applied in other areas such as robotics.
But it's quite data intensive and often [not the right approach](https://www.alexirpan.com/2018/02/14/rl-hard.html).

<!--
## Impressive to Look At

With all the hype, it's quite surprising how little real world applications there are in practice.
The reason is that reinforcement learning is difficult to get right.
Training can be quite unstable.
And the most difficult is, that, in order to get in enough training, it's almost impossible to train it in the real world.
This means that it's either restricted to simulations or the application itself is completely digital, like a game.
And these are the prime starting points: games and simulations.
That's also why the most impressive headlines were games beating human players.
But if you want to train a robotic arm to grap an item and put it into another spot.
It's harder.
You first need a simulation and train the reinforcement learning agent in a simulation.
But it's also difficult to make the transfer from simulation to reality.
From the simulated robotic arm to the physical one.
-->


## Strengths

- Reinforcement learning allows us to model the world in a dynamic way.
- It's a great approach for planning, playing games, controlling robots and larger systems.
- Actions of the agent change the environment. In other mindsets, the model is a mere "observer", which often is a false simplification.
- Reinforcement learning seems to be the  modeling paradigm that most closely mimics animal intelligence.
- Reinforcement learning is proactive. It involves learning by doing, balancing exploration and exploitation, and creating experiments on the fly.


## Limitations

- Reinforcement learning requires that the task involve some form of agent. Many modeling tasks don't fit this scenario.
- Very often, reinforcement learning, especially deep reinforcement learning, is the [wrong approach to a problem](https://www.alexirpan.com/2018/02/14/rl-hard.html).
- Reinforcement learning models can be very difficult to train and reproduce:
  - Learning requires many episodes because reinforcement learning is sample inefficient.
  - Designing the right reward function can be tricky.
  - Training can be unstable and can get stuck in local optima.
- Reinforcement learning models are usually trained in artificial digital environments. It's difficult to transfer the models to the physical world.
- The reasons why reinforcement learning models are not trained in the real world are due to the large number of required training episodes and the risks of real-world experiments. Remember the pricing example: It's probably too risky for any business to let a reinforcement learning algorithm experiment with prices in real time.
- Model-free or model-based? Learn the policy? Or the value function? Or the action-value function? There are many modeling choices and this can be overwhelming.



## References

- A very comprehensive reference is the book: Reinforcement Learning, An Introduction [@sutton2018reinforcement]
- The paper "The surprising creativity of digital evolution" is one of my all-time favorite papers[@lehman2020surprising]. It deals with evolutionary algorithms, but it also has more general lessons about how difficult it is to design an optimization goal.


[^pretrained]: Data may be collected beforehand. For example, the Alpha Go algorithm was pre-trained by Go moves from human players (in a supervised learning fashion). [@chen2018recurrent]



